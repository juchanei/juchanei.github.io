1:HL["/_next/static/css/d32bf43455ded298.css",{"as":"style"}]
0:[[["",{"children":["articles",{"children":[["slug","Event-sourcing","d"],{"children":["__PAGE__?{\"slug\":\"Event-sourcing\"}",{}]}]}]},"$undefined","$undefined",true],"$L2",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/d32bf43455ded298.css","precedence":"next"}]],["$L3",null]]]]
4:HL["/_next/static/css/e175a87955b7f53c.css",{"as":"style"}]
5:I{"id":"7951","chunks":["414:static/chunks/414-1f2b980871695451.js","185:static/chunks/app/layout-a1437d56a8d70c68.js"],"name":"","async":false}
6:I{"id":"414","chunks":["414:static/chunks/414-1f2b980871695451.js","222:static/chunks/app/articles/page-396ceb5d519c38af.js"],"name":"","async":false}
7:I{"id":"9544","chunks":["272:static/chunks/webpack-df73c3a7ea0771f4.js","667:static/chunks/2443530c-82eff788789df68b.js","139:static/chunks/139-0eb3f6144d0a8a28.js"],"name":"","async":false}
8:I{"id":"99","chunks":["272:static/chunks/webpack-df73c3a7ea0771f4.js","667:static/chunks/2443530c-82eff788789df68b.js","139:static/chunks/139-0eb3f6144d0a8a28.js"],"name":"","async":false}
9:I{"id":"8607","chunks":["943:static/chunks/943-e365b4e8cd375ef4.js","83:static/chunks/app/articles/[slug]/page-4dc4cd3d17050a2d.js"],"name":"","async":false}
2:[["$","html",null,{"lang":"ko","children":[["$","head",null,{"children":[["$","title",null,{"children":"juchanei"}],["$","meta",null,{"name":"description","content":"$undefined"}],["$","meta",null,{"property":"og:site_name","content":"juchanei"}],["$","meta",null,{"property":"og:type","content":"blog"}],["$","meta",null,{"property":"og:title","content":"juchanei"}],["$","meta",null,{"property":"og:image","content":"/logo_transparent.png"}],["$","meta",null,{"property":"og:url","content":"https://juchanei.github.io"}],["$","meta",null,{"property":"og:description","content":"$undefined"}],["$","meta",null,{"property":"og:locale","content":"ko_KR"}],["$","meta",null,{"name":"twitter:card","content":"summary"}],["$","meta",null,{"name":"twitter:title","content":"juchanei"}],["$","meta",null,{"name":"twitter:description","content":"$undefined"}],["$","meta",null,{"name":"twitter:image","content":"/logo_transparent.png"}],["$","meta",null,{"name":"google-site-verification","content":"zMe30NikxkVrHQc8KL1LeFDlYRx13BypWzaXpglLe3Q"}],["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"}],["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css","media":"screen and (prefers-color-scheme: dark)"}]]}],["$","$L5",null,{"src":"https://www.googletagmanager.com/gtag/js?id=G-JRWY82TBQY","strategy":"afterInteractive"}],["$","$L5",null,{"id":"google-analytics","strategy":"afterInteractive","children":"\n                window.dataLayer = window.dataLayer || [];\n                function gtag(){window.dataLayer.push(arguments);}\n                gtag('js', new Date());\n\n                gtag('config', 'G-JRWY82TBQY');\n                "}],["$","body",null,{"children":["$","main",null,{"className":"Layout_main__maYPe","children":[["$","header",null,{"children":[["$","$L6",null,{"className":"Layout_logo__tEsDc","href":"/","children":"juchanei"}],["$","nav",null,{"children":["$","ul",null,{"children":[["$","li","/about",{"children":["$","$L6",null,{"href":"/about","target":"$undefined","children":"about"}]}],["$","li","/articles",{"children":["$","$L6",null,{"href":"/articles","target":"$undefined","children":"articles"}]}],["$","li","https://github.com/juchanei",{"children":["$","$L6",null,{"href":"https://github.com/juchanei","target":"blank","children":"github"}]}]]}]}]]}],["$","article",null,{"children":["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L8",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children","articles","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L8",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children","articles","children",["slug","Event-sourcing","d"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L8",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":[["$","$L9",null,{"title":"Event sourcing","date":"$D2022-11-30T14:23:00.000Z","tags":["microservice","transaction","message","event"],"html":"<blockquote>\n<p><a href=\"https://microservices.io/patterns/data/event-sourcing.html\">https://microservices.io/patterns/data/event-sourcing.html</a>을 번역한 글입니다.</p>\n</blockquote>\n<h2 id=\"context\">Context</h2>\n<p>전형적인 서비스 커맨드는 데이터베이스를 업데이트 하는 동시에 메시지/이벤트를 발송할 필요가 있다. 예를 들면, <a href=\"https://microservices.io/patterns/data/saga.html\">saga</a>에 참여하는 서비스는 데이터베이스 업데이트와 메시지/이벤트 발행을 원자적으로 수행해야 한다. <a href=\"https://microservices.io/patterns/data/domain-event.html\">도메인 이벤트</a>(domain event)를 발행하는 서비스 역시 <a href=\"https://microservices.io/patterns/data/aggregate.html\">aggregate</a>을 업데이트하고 이벤트를 발행하는 동작을 원자적으로 수행해야 한다.</p>\n<p>서비스 커맨드는 일반적으로 데이터베이스를 업데이트하는 <strong>동시에</strong> 메시지/이벤트를 발송한다. 그러나 메시지 브로커는 보통 전통적인 분산 트랜잭션(Two phase commit, 2PC)를 지원하지 않기 때문에, 데이터베이스와 메시지 브로커에 걸쳐 업데이트와 메시지/이벤트 발행을 원자적으로 수행할 수 없다. 만약 가능하다 하더라도 서비스가 데이터베이스와 메시지에 모두 결합되는 구조는 바람직 하지 않을 수 있다.</p>\n<p>하지만 2PC를 사용하지 않으면, 트랜잭션 중에 메시지가 발송된 것을 확신할 수 없다. 트랜잭션이 커밋 되는 것을 보장할 수 없을 뿐만 아니라, 트랜잭션 커밋 후 메시지 발송 중에 크래시가 발생하지 않는다는 것 또한 보장할 수 없다.</p>\n<p>더불어, 메시지는 반드시 서비스가 발송한 순서대로 메시지 브로커에 도착해야 한다. 예를 들면, 서비스에서 한 aggregate이 트랜잭션 <code>T1</code>, <code>T2</code>에 의해 업데이트 된다고 하자. 두 트랜잭션은  같은 서비스 인스턴스에서 수행될 수도 있고 다른 서비스 인스턴스에서 수행될 수도 있다. 각각 트랜잭션은 대응되는 이벤트 <code>E1</code>, <code>E2</code>가 있다. 이 때 만일 트랜잭션 <code>T1</code> 다음에 <code>T2</code>가 수행된다면, 이벤트 <code>E2</code>는 반드시 <code>E1</code> 다음에 발행되어야 한다.</p>\n<h2 id=\"problem\">Problem</h2>\n<p>어떻게 데이터베이스 업데이트와 메시지/이벤트 발행을 안정적/원자적으로 할 수 있을까?</p>\n<h2 id=\"forces\">Forces</h2>\n<ul>\n<li>2PC는 사용하지 않는다.</li>\n<li>만약 데이터베이스 트랜잭션이 커밋됐다면, 메시지는 반드시 발송되어야 한다. 반대로 데이터베이스가 롤백되었다면, 메시지는 발송되지 않아야 한다.</li>\n<li>메시지는 반드시 서비스가 발송한 순서대로 메시지 브로커에 도착해야 한다. 같은 aggregate을 업데이트하는 다수에 서비스 인스턴스에 걸쳐서 이 순서는 반드시 지켜져야 한다.</li>\n</ul>\n<h2 id=\"solution\">Solution</h2>\n<p>이를 해결하기 위한 좋은 방안으로 이벤트 소싱이 있다. 이벤트 소싱은 <code>Order</code>, <code>Customer</code>와 같은 비즈니스 엔터티의 상태를 ‘연속된 상태 변화 이벤트’로 유지한다. 비즈니스 엔터티의 상태가 변경될 때 마다 이벤트 리스트에 새 이벤트가 추가된다. 이벤트를 한번에 저장하기 때문에 이 오퍼레이션은 기본적으로 원자적이다. 애플리케이션은 이 이벤트들을 다시 재생(replay)하여 엔터티를 재구성 한다.</p>\n<p>애플리케이션은 이벤트를 이벤트 스토어(데이터베이스)에 저장한다.  이벤트 스토어는 이벤트 저장, 조회 뿐만 아니라 메시지 브로커 처럼 이벤트를 구독할 수 있도록 API를 제공한다. 따라서 한 서비스가 이벤트를 스토어에 저장하면 이를 구독하는 서비스들에게 이벤트가 전달 된다.</p>\n<p><code>Customer</code>와 같이 일부 엔터티는 매우 많은 이벤트를 가질 수 있다. 로딩을 최적화 하기 위해서 애플리케이션은 현재 엔터티 상태의 스냅샷을 주기적으로 저장한다. 애플리케이션은 가장 최근 스냅샷과 그 이후에 발생한 이벤트를 찾아서 현재 상태를 재구성한다. 결과적으로 적은 수의 이벤트만 재생하여 현재 상태를 얻을 수 있다.</p>\n<h2 id=\"example\">Example</h2>\n<p>아래는 이벤트 소싱과 <a href=\"https://microservices.io/patterns/data/cqrs.html\">CQRS</a>로 만든 <a href=\"https://github.com/eventuate-examples/eventuate-examples-java-customers-and-orders\">Customers and Orders 예제 애플리케이션</a>의 일부이다. 어플리캐이션은 Java로 작성되었으며 Spring Boot와 <a href=\"http://eventuate.io/\">Eventuate</a>를 사용한다.</p>\n<p>아래 다이어그램은 <code>Order</code>를 어떻게 관리하는지 보여준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/10704195/204835063-c87078d7-26d6-4588-a052-460feaaf9c9e.png\" alt=\"image\"></p>\n<p>어플리케이션은 <code>ORDERS</code> 테이블에 <code>Order</code>의 현재 상태를 row로 저장하는 대신, 연속 된 <code>Order 이벤트</code>를 저장한다. <code>CustomerService</code>는 <code>Order 이벤트</code>를 구독하고 자기 자신의 상태를 업데이트한다.</p>\n<p>아래는 <code>Order</code> aggregate이다</p>\n<pre><code class=\"language-java\">public class Order extends ReflectiveMutableCommandProcessingAggregate&lt;Order, OrderCommand&gt; {\n\n  private OrderState state;\n  private String customerId;\n\n  public OrderState getState() {\n    return state;\n  }\n\n  public List&lt;Event&gt; process(CreateOrderCommand cmd) {\n    return EventUtil.events(new OrderCreatedEvent(cmd.getCustomerId(), cmd.getOrderTotal()));\n  }\n\n  public List&lt;Event&gt; process(ApproveOrderCommand cmd) {\n    return EventUtil.events(new OrderApprovedEvent(customerId));\n  }\n\n  public List&lt;Event&gt; process(RejectOrderCommand cmd) {\n    return EventUtil.events(new OrderRejectedEvent(customerId));\n  }\n\n  public void apply(OrderCreatedEvent event) {\n    this.state = OrderState.CREATED;\n    this.customerId = event.getCustomerId();\n  }\n\n  public void apply(OrderApprovedEvent event) {\n    this.state = OrderState.APPROVED;\n  }\n\n  public void apply(OrderRejectedEvent event) {\n    this.state = OrderState.REJECTED;\n  }\n</code></pre>\n<p>아래는 <code>Order 이벤트</code>를 구독하는 <code>CustomerService</code>의 이벤트 핸들러중 일부이다.</p>\n<pre><code class=\"language-java\">@EventSubscriber(id = &quot;customerWorkflow&quot;)\npublic class CustomerWorkflow {\n\n  @EventHandlerMethod\n  public CompletableFuture&lt;EntityWithIdAndVersion&lt;Customer&gt;&gt; reserveCredit(\n          EventHandlerContext&lt;OrderCreatedEvent&gt; ctx) {\n    OrderCreatedEvent event = ctx.getEvent();\n    Money orderTotal = event.getOrderTotal();\n    String customerId = event.getCustomerId();\n    String orderId = ctx.getEntityId();\n\n    return ctx.update(Customer.class, customerId, new ReserveCreditCommand(orderTotal, orderId));\n  }\n\n}\n</code></pre>\n<p>핸들러는 고객의 신용 예약을 시도하여 <code>OrderCreated</code> 이벤트를 처리한다.</p>\n<p>이 외에 이벤트 소싱을 어떻게 사용하는지 보여주는 <a href=\"https://eventuate.io/exampleapps.html\">몇가지 예제 애플리케이션</a>이 있다.</p>\n<h2 id=\"resulting-context\">Resulting context</h2>\n<p>이벤트 소싱의 장점</p>\n<ul>\n<li>이벤트 소싱은 EDA(Event-driven Architecture)를 구현하는데 있어 주요한 문제들을 해결하며, 상태 변화마다 안정적으로 이벤트를 발행하도록 한다.</li>\n<li>도메인 객체 대신 이벤트를 저장하기 때문에 객체-관계형 데이터베이스 간의 임피던스 미스매칭 문제를 피할 수 있다.</li>\n<li>이벤트 소싱은 비즈니스 엔터티가 변경될 때 마다 100% 신뢰할 수 있는 <a href=\"https://microservices.io/patterns/observability/audit-logging\">audit log</a>를 제공한다.</li>\n<li>특정 시점의 상태를 결정하기 위한 위한 임시 쿼리 구현할 수 있다.</li>\n<li>이벤트 소싱 기반의 비즈니스 로직은 이벤트를 교환하는 느슨하게 결합의 엔터티로 구성된다. 따라서 모놀로딕 애플리케이션에서 마이크로서비스 아키텍처로 쉽게 마이그레이션 할 수 있다.</li>\n</ul>\n<p>이벤트 소싱의 단점</p>\n<ul>\n<li>보통의 프로그래밍 스타일과 다르므로 러닝커브가 있다.</li>\n<li>스토어에 이벤트를 요청할 때 비즈니스 엔터티를 재구성하기 위한 반복적인 쿼리를 필요로 하기 때문에 어렵다. 이는 복잡하고 비효율적이다. 따라서, 어플리케이션은 반드시 <a href=\"https://microservices.io/patterns/data/cqrs.html\">CQRS(Command Query Responsibility Segregation)</a>을 사용하여야 한다. 어플리케이션은 반드시 ‘최종적으로 일관된 데이터’를 다뤄야 함을 의미한다.</li>\n</ul>\n<h2 id=\"related-patterns\">Related patterns</h2>\n<ul>\n<li>이 패턴을 <a href=\"https://microservices.io/patterns/data/saga.html\">Saga</a>와 <a href=\"https://microservices.io/patterns/data/domain-event.html\">Domain event</a> 패턴을 위해 만들어 졌다.</li>\n<li>높은 확률로 이벤트 소싱과 <a href=\"https://microservices.io/patterns/data/cqrs.html\">CQRS</a>는 함께 사용된다.</li>\n<li>이벤트 소싱은 <a href=\"https://microservices.io/patterns/observability/audit-logging\">Audit logging</a> 패턴을 구현한다.</li>\n</ul>\n<h2 id=\"see-also\">See also</h2>\n<ul>\n<li><a href=\"http://eventuate.io/\">Eventuate</a>은 이벤트 소싱과 CQRS 어플리케이션을 개발하기 위한 플랫폼이다.</li>\n<li><a href=\"https://eventuate.io/articles.html\">이벤트 소싱과 CQRS에 관한 아티클</a></li>\n<li><a href=\"https://blog.eventuate.io/2017/03/07/eventuate-local-now-supports-snapshots/\">Eventuate가 스냅샷을 구현하는 방법</a></li>\n</ul>\n"}],null],"segment":"__PAGE__?{\"slug\":\"Event-sourcing\"}"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e175a87955b7f53c.css","precedence":"next"}]]}],"segment":["slug","Event-sourcing","d"]},"styles":[]}],"segment":"articles"},"styles":[]}]}],["$","footer",null,{"children":["$","span",null,{"children":["Github (",["$","a",null,{"href":"https://github.com/juchanei","children":"@juchanei"}],")"]}]}]]}]}]]}],null]
3:[[["$","meta",null,{"charSet":"utf-8"}],null,null,null,null,null,null,null,null,null,null,["$","meta",null,{"name":"viewport","content":"width=device-width, initial-scale=1"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,null]

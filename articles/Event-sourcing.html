<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><link rel="stylesheet" href="/_next/static/css/d32bf43455ded298.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/e175a87955b7f53c.css" data-precedence="next"/><link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"/><link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css" media="screen and (prefers-color-scheme: dark)"/><link rel="preload" as="script" href="https://www.googletagmanager.com/gtag/js?id=G-JRWY82TBQY"/><title>juchanei</title><meta name="description"/><meta property="og:site_name" content="juchanei"/><meta property="og:type" content="blog"/><meta property="og:title" content="juchanei"/><meta property="og:image" content="/logo_transparent.png"/><meta property="og:url" content="https://juchanei.github.io"/><meta property="og:description"/><meta property="og:locale" content="ko_KR"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="juchanei"/><meta name="twitter:description"/><meta name="twitter:image" content="/logo_transparent.png"/><meta name="google-site-verification" content="zMe30NikxkVrHQc8KL1LeFDlYRx13BypWzaXpglLe3Q"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css" media="screen and (prefers-color-scheme: dark)"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" noModule=""></script></head><body><main class="Layout_main__maYPe"><header><a class="Layout_logo__tEsDc" href="/">juchanei</a><nav><ul><li><a href="/about">about</a></li><li><a href="/articles">articles</a></li><li><a target="blank" href="https://github.com/juchanei">github</a></li></ul></nav></header><article><h1>Event sourcing</h1><time>November 30, 2022</time><hr class="Article_bar__LgwyR"/><div class="Article_blog-post-content__vjQ_B"><blockquote>
<p><a href="https://microservices.io/patterns/data/event-sourcing.html">https://microservices.io/patterns/data/event-sourcing.html</a>을 번역한 글입니다.</p>
</blockquote>
<h2 id="context">Context</h2>
<p>전형적인 서비스 커맨드는 데이터베이스를 업데이트 하는 동시에 메시지/이벤트를 발송할 필요가 있다. 예를 들면, <a href="https://microservices.io/patterns/data/saga.html">saga</a>에 참여하는 서비스는 데이터베이스 업데이트와 메시지/이벤트 발행을 원자적으로 수행해야 한다. <a href="https://microservices.io/patterns/data/domain-event.html">도메인 이벤트</a>(domain event)를 발행하는 서비스 역시 <a href="https://microservices.io/patterns/data/aggregate.html">aggregate</a>을 업데이트하고 이벤트를 발행하는 동작을 원자적으로 수행해야 한다.</p>
<p>서비스 커맨드는 일반적으로 데이터베이스를 업데이트하는 <strong>동시에</strong> 메시지/이벤트를 발송한다. 그러나 메시지 브로커는 보통 전통적인 분산 트랜잭션(Two phase commit, 2PC)를 지원하지 않기 때문에, 데이터베이스와 메시지 브로커에 걸쳐 업데이트와 메시지/이벤트 발행을 원자적으로 수행할 수 없다. 만약 가능하다 하더라도 서비스가 데이터베이스와 메시지에 모두 결합되는 구조는 바람직 하지 않을 수 있다.</p>
<p>하지만 2PC를 사용하지 않으면, 트랜잭션 중에 메시지가 발송된 것을 확신할 수 없다. 트랜잭션이 커밋 되는 것을 보장할 수 없을 뿐만 아니라, 트랜잭션 커밋 후 메시지 발송 중에 크래시가 발생하지 않는다는 것 또한 보장할 수 없다.</p>
<p>더불어, 메시지는 반드시 서비스가 발송한 순서대로 메시지 브로커에 도착해야 한다. 예를 들면, 서비스에서 한 aggregate이 트랜잭션 <code>T1</code>, <code>T2</code>에 의해 업데이트 된다고 하자. 두 트랜잭션은  같은 서비스 인스턴스에서 수행될 수도 있고 다른 서비스 인스턴스에서 수행될 수도 있다. 각각 트랜잭션은 대응되는 이벤트 <code>E1</code>, <code>E2</code>가 있다. 이 때 만일 트랜잭션 <code>T1</code> 다음에 <code>T2</code>가 수행된다면, 이벤트 <code>E2</code>는 반드시 <code>E1</code> 다음에 발행되어야 한다.</p>
<h2 id="problem">Problem</h2>
<p>어떻게 데이터베이스 업데이트와 메시지/이벤트 발행을 안정적/원자적으로 할 수 있을까?</p>
<h2 id="forces">Forces</h2>
<ul>
<li>2PC는 사용하지 않는다.</li>
<li>만약 데이터베이스 트랜잭션이 커밋됐다면, 메시지는 반드시 발송되어야 한다. 반대로 데이터베이스가 롤백되었다면, 메시지는 발송되지 않아야 한다.</li>
<li>메시지는 반드시 서비스가 발송한 순서대로 메시지 브로커에 도착해야 한다. 같은 aggregate을 업데이트하는 다수에 서비스 인스턴스에 걸쳐서 이 순서는 반드시 지켜져야 한다.</li>
</ul>
<h2 id="solution">Solution</h2>
<p>이를 해결하기 위한 좋은 방안으로 이벤트 소싱이 있다. 이벤트 소싱은 <code>Order</code>, <code>Customer</code>와 같은 비즈니스 엔터티의 상태를 ‘연속된 상태 변화 이벤트’로 유지한다. 비즈니스 엔터티의 상태가 변경될 때 마다 이벤트 리스트에 새 이벤트가 추가된다. 이벤트를 한번에 저장하기 때문에 이 오퍼레이션은 기본적으로 원자적이다. 애플리케이션은 이 이벤트들을 다시 재생(replay)하여 엔터티를 재구성 한다.</p>
<p>애플리케이션은 이벤트를 이벤트 스토어(데이터베이스)에 저장한다.  이벤트 스토어는 이벤트 저장, 조회 뿐만 아니라 메시지 브로커 처럼 이벤트를 구독할 수 있도록 API를 제공한다. 따라서 한 서비스가 이벤트를 스토어에 저장하면 이를 구독하는 서비스들에게 이벤트가 전달 된다.</p>
<p><code>Customer</code>와 같이 일부 엔터티는 매우 많은 이벤트를 가질 수 있다. 로딩을 최적화 하기 위해서 애플리케이션은 현재 엔터티 상태의 스냅샷을 주기적으로 저장한다. 애플리케이션은 가장 최근 스냅샷과 그 이후에 발생한 이벤트를 찾아서 현재 상태를 재구성한다. 결과적으로 적은 수의 이벤트만 재생하여 현재 상태를 얻을 수 있다.</p>
<h2 id="example">Example</h2>
<p>아래는 이벤트 소싱과 <a href="https://microservices.io/patterns/data/cqrs.html">CQRS</a>로 만든 <a href="https://github.com/eventuate-examples/eventuate-examples-java-customers-and-orders">Customers and Orders 예제 애플리케이션</a>의 일부이다. 어플리캐이션은 Java로 작성되었으며 Spring Boot와 <a href="http://eventuate.io/">Eventuate</a>를 사용한다.</p>
<p>아래 다이어그램은 <code>Order</code>를 어떻게 관리하는지 보여준다.</p>
<p><img src="https://user-images.githubusercontent.com/10704195/204835063-c87078d7-26d6-4588-a052-460feaaf9c9e.png" alt="image"></p>
<p>어플리케이션은 <code>ORDERS</code> 테이블에 <code>Order</code>의 현재 상태를 row로 저장하는 대신, 연속 된 <code>Order 이벤트</code>를 저장한다. <code>CustomerService</code>는 <code>Order 이벤트</code>를 구독하고 자기 자신의 상태를 업데이트한다.</p>
<p>아래는 <code>Order</code> aggregate이다</p>
<pre><code class="language-java">public class Order extends ReflectiveMutableCommandProcessingAggregate&lt;Order, OrderCommand&gt; {

  private OrderState state;
  private String customerId;

  public OrderState getState() {
    return state;
  }

  public List&lt;Event&gt; process(CreateOrderCommand cmd) {
    return EventUtil.events(new OrderCreatedEvent(cmd.getCustomerId(), cmd.getOrderTotal()));
  }

  public List&lt;Event&gt; process(ApproveOrderCommand cmd) {
    return EventUtil.events(new OrderApprovedEvent(customerId));
  }

  public List&lt;Event&gt; process(RejectOrderCommand cmd) {
    return EventUtil.events(new OrderRejectedEvent(customerId));
  }

  public void apply(OrderCreatedEvent event) {
    this.state = OrderState.CREATED;
    this.customerId = event.getCustomerId();
  }

  public void apply(OrderApprovedEvent event) {
    this.state = OrderState.APPROVED;
  }

  public void apply(OrderRejectedEvent event) {
    this.state = OrderState.REJECTED;
  }
</code></pre>
<p>아래는 <code>Order 이벤트</code>를 구독하는 <code>CustomerService</code>의 이벤트 핸들러중 일부이다.</p>
<pre><code class="language-java">@EventSubscriber(id = &quot;customerWorkflow&quot;)
public class CustomerWorkflow {

  @EventHandlerMethod
  public CompletableFuture&lt;EntityWithIdAndVersion&lt;Customer&gt;&gt; reserveCredit(
          EventHandlerContext&lt;OrderCreatedEvent&gt; ctx) {
    OrderCreatedEvent event = ctx.getEvent();
    Money orderTotal = event.getOrderTotal();
    String customerId = event.getCustomerId();
    String orderId = ctx.getEntityId();

    return ctx.update(Customer.class, customerId, new ReserveCreditCommand(orderTotal, orderId));
  }

}
</code></pre>
<p>핸들러는 고객의 신용 예약을 시도하여 <code>OrderCreated</code> 이벤트를 처리한다.</p>
<p>이 외에 이벤트 소싱을 어떻게 사용하는지 보여주는 <a href="https://eventuate.io/exampleapps.html">몇가지 예제 애플리케이션</a>이 있다.</p>
<h2 id="resulting-context">Resulting context</h2>
<p>이벤트 소싱의 장점</p>
<ul>
<li>이벤트 소싱은 EDA(Event-driven Architecture)를 구현하는데 있어 주요한 문제들을 해결하며, 상태 변화마다 안정적으로 이벤트를 발행하도록 한다.</li>
<li>도메인 객체 대신 이벤트를 저장하기 때문에 객체-관계형 데이터베이스 간의 임피던스 미스매칭 문제를 피할 수 있다.</li>
<li>이벤트 소싱은 비즈니스 엔터티가 변경될 때 마다 100% 신뢰할 수 있는 <a href="https://microservices.io/patterns/observability/audit-logging">audit log</a>를 제공한다.</li>
<li>특정 시점의 상태를 결정하기 위한 위한 임시 쿼리 구현할 수 있다.</li>
<li>이벤트 소싱 기반의 비즈니스 로직은 이벤트를 교환하는 느슨하게 결합의 엔터티로 구성된다. 따라서 모놀로딕 애플리케이션에서 마이크로서비스 아키텍처로 쉽게 마이그레이션 할 수 있다.</li>
</ul>
<p>이벤트 소싱의 단점</p>
<ul>
<li>보통의 프로그래밍 스타일과 다르므로 러닝커브가 있다.</li>
<li>스토어에 이벤트를 요청할 때 비즈니스 엔터티를 재구성하기 위한 반복적인 쿼리를 필요로 하기 때문에 어렵다. 이는 복잡하고 비효율적이다. 따라서, 어플리케이션은 반드시 <a href="https://microservices.io/patterns/data/cqrs.html">CQRS(Command Query Responsibility Segregation)</a>을 사용하여야 한다. 어플리케이션은 반드시 ‘최종적으로 일관된 데이터’를 다뤄야 함을 의미한다.</li>
</ul>
<h2 id="related-patterns">Related patterns</h2>
<ul>
<li>이 패턴을 <a href="https://microservices.io/patterns/data/saga.html">Saga</a>와 <a href="https://microservices.io/patterns/data/domain-event.html">Domain event</a> 패턴을 위해 만들어 졌다.</li>
<li>높은 확률로 이벤트 소싱과 <a href="https://microservices.io/patterns/data/cqrs.html">CQRS</a>는 함께 사용된다.</li>
<li>이벤트 소싱은 <a href="https://microservices.io/patterns/observability/audit-logging">Audit logging</a> 패턴을 구현한다.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="http://eventuate.io/">Eventuate</a>은 이벤트 소싱과 CQRS 어플리케이션을 개발하기 위한 플랫폼이다.</li>
<li><a href="https://eventuate.io/articles.html">이벤트 소싱과 CQRS에 관한 아티클</a></li>
<li><a href="https://blog.eventuate.io/2017/03/07/eventuate-local-now-supports-snapshots/">Eventuate가 스냅샷을 구현하는 방법</a></li>
</ul>
</div></article><footer><span>Github (<a href="https://github.com/juchanei">@juchanei</a>)</span></footer></main><script src="/_next/static/chunks/webpack-df73c3a7ea0771f4.js" async=""></script><script src="/_next/static/chunks/2443530c-82eff788789df68b.js" async=""></script><script src="/_next/static/chunks/139-0eb3f6144d0a8a28.js" async=""></script><script src="/_next/static/chunks/main-app-527630b440ad130e.js" async=""></script></body></html><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/d32bf43455ded298.css\",{\"as\":\"style\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/css/e175a87955b7f53c.css\",{\"as\":\"style\"}]\n"])</script><script>self.__next_f.push([1,"4:I{\"id\":\"7858\",\"chunks\":[\"272:static/chunks/webpack-df73c3a7ea0771f4.js\",\"667:static/chunks/2443530c-82eff788789df68b.js\",\"139:static/chunks/139-0eb3f6144d0a8a28.js\"],\"name\":\"\",\"async\":false}\n6:I{\"id\":\"3055\",\"chunks\":[\"272:static/chunks/webpack-df73c3a7ea0771f4.js\",\"667:static/chunks/2443530c-82eff788789df68b.js\",\"139:static/chunks/139-0eb3f6144d0a8a28.js\"],\"name\":\"\",\"async\":false}\n7:I{\"id\":\"7951\",\"chunks\":[\"414:static/chunks/414-1f2b980871695451.js\",\"185:static/chunks/app/layout-a1437d56a8d70c68.js\"],\"nam"])</script><script>self.__next_f.push([1,"e\":\"\",\"async\":false}\n8:I{\"id\":\"414\",\"chunks\":[\"414:static/chunks/414-1f2b980871695451.js\",\"222:static/chunks/app/articles/page-396ceb5d519c38af.js\"],\"name\":\"\",\"async\":false}\n9:I{\"id\":\"9544\",\"chunks\":[\"272:static/chunks/webpack-df73c3a7ea0771f4.js\",\"667:static/chunks/2443530c-82eff788789df68b.js\",\"139:static/chunks/139-0eb3f6144d0a8a28.js\"],\"name\":\"\",\"async\":false}\na:I{\"id\":\"99\",\"chunks\":[\"272:static/chunks/webpack-df73c3a7ea0771f4.js\",\"667:static/chunks/2443530c-82eff788789df68b.js\",\"139:static/chunks/139-0"])</script><script>self.__next_f.push([1,"eb3f6144d0a8a28.js\"],\"name\":\"\",\"async\":false}\nb:I{\"id\":\"8607\",\"chunks\":[\"943:static/chunks/943-e365b4e8cd375ef4.js\",\"83:static/chunks/app/articles/[slug]/page-4dc4cd3d17050a2d.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d32bf43455ded298.css\",\"precedence\":\"next\"}]],[\"$\",\"$L4\",null,{\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/articles/Event-sourcing\",\"initialTree\":[\"\",{\"children\":[\"articles\",{\"children\":[[\"slug\",\"Event-sourcing\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"Event-sourcing\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[\"$L5\",null],\"globalErrorComponent\":\"$6\",\"notFound\":[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"title\",null,{\"children\":\"juchanei\"}],[\"$\",\"meta\",null,{\"name\":\"description\",\"content\":\"$undefined\"}],[\"$\",\"meta\",null,{\"property\":\"og:site_name\",\"content\":\"juchanei\"}],[\"$\",\"meta\",null,{\"property\":\"og:type\",\"content\":\"blog\"}],[\"$\",\"meta\",null,{\"property\":\"og:title\",\"content\":\"juchanei\"}],[\"$\",\"meta\",null,{\"property\":\"og:image\",\"content\":\"/logo_transparent.png\"}],[\"$\",\"meta\",null,{\"property\":\"og:url\",\"content\":\"https://juchanei.github.io\"}],[\"$\",\"meta\",null,{\"property\":\"og:description\",\"content\":\"$undefined\"}],[\"$\",\"meta\",null,{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",null,{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",null,{\"name\":\"twitter:title\",\"content\":\"juchanei\"}],[\"$\",\"meta\",null,{\"name\":\"twitter:description\",\"content\":\"$undefined\"}],[\"$\",\"meta\",null,{\"name\":\"twitter:image\",\"content\":\"/logo_transparent.png\"}],[\"$\",\"meta\",null,{\"name\":\"google-site-verification\",\"content\":\"zMe30NikxkVrHQc8KL1LeFDlYRx13BypWzaXpglLe3Q\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css\",\"media\":\"screen and (prefers-color-scheme: dark)\"}]]}],[\"$\",\"$L7\",null,{\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-JRWY82TBQY\",\"strategy\":\"afterInteractive\"}],[\"$\",\"$L7\",null,{\"id\":\"google-analytics\",\"strategy\":\"afterInteractive\",\"children\":\"\\n                window.dataLayer = window.dataLayer || [];\\n                function gtag(){window.dataLayer.push(arguments);}\\n                gtag('js', new Date());\\n\\n                gtag('config', 'G-JRWY82TBQY');\\n                \"}],[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"className\":\"Layout_main__maYPe\",\"children\":[[\"$\",\"header\",null,{\"children\":[[\"$\",\"$L8\",null,{\"className\":\"Layout_logo__tEsDc\",\"href\":\"/\",\"children\":\"juchanei\"}],[\"$\",\"nav\",null,{\"children\":[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",\"/about\",{\"children\":[\"$\",\"$L8\",null,{\"href\":\"/about\",\"target\":\"$undefined\",\"children\":\"about\"}]}],[\"$\",\"li\",\"/articles\",{\"children\":[\"$\",\"$L8\",null,{\"href\":\"/articles\",\"target\":\"$undefined\",\"children\":\"articles\"}]}],[\"$\",\"li\",\"https://github.com/juchanei\",{\"children\":[\"$\",\"$L8\",null,{\"href\":\"https://github.com/juchanei\",\"target\":\"blank\",\"children\":\"github\"}]}]]}]}]]}],[\"$\",\"article\",null,{\"children\":[\"$undefined\",[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]]}],[\"$\",\"footer\",null,{\"children\":[\"$\",\"span\",null,{\"children\":[\"Github (\",[\"$\",\"a\",null,{\"href\":\"https://github.com/juchanei\",\"children\":\"@juchanei\"}],\")\"]}]}]]}]}]]}],\"asNotFound\":false,\"children\":[[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"title\",null,{\"children\":\"juchanei\"}],[\"$\",\"meta\",null,{\"name\":\"description\",\"content\":\"$undefined\"}],[\"$\",\"meta\",null,{\"property\":\"og:site_name\",\"content\":\"juchanei\"}],[\"$\",\"meta\",null,{\"property\":\"og:type\",\"content\":\"blog\"}],[\"$\",\"meta\",null,{\"property\":\"og:title\",\"content\":\"juchanei\"}],[\"$\",\"meta\",null,{\"property\":\"og:image\",\"content\":\"/logo_transparent.png\"}],[\"$\",\"meta\",null,{\"property\":\"og:url\",\"content\":\"https://juchanei.github.io\"}],[\"$\",\"meta\",null,{\"property\":\"og:description\",\"content\":\"$undefined\"}],[\"$\",\"meta\",null,{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",null,{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",null,{\"name\":\"twitter:title\",\"content\":\"juchanei\"}],[\"$\",\"meta\",null,{\"name\":\"twitter:description\",\"content\":\"$undefined\"}],[\"$\",\"meta\",null,{\"name\":\"twitter:image\",\"content\":\"/logo_transparent.png\"}],[\"$\",\"meta\",null,{\"name\":\"google-site-verification\",\"content\":\"zMe30NikxkVrHQc8KL1LeFDlYRx13BypWzaXpglLe3Q\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css\",\"media\":\"screen and (prefers-color-scheme: dark)\"}]]}],[\"$\",\"$L7\",null,{\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-JRWY82TBQY\",\"strategy\":\"afterInteractive\"}],[\"$\",\"$L7\",null,{\"id\":\"google-analytics\",\"strategy\":\"afterInteractive\",\"children\":\"\\n                window.dataLayer = window.dataLayer || [];\\n                function gtag(){window.dataLayer.push(arguments);}\\n                gtag('js', new Date());\\n\\n                gtag('config', 'G-JRWY82TBQY');\\n                \"}],[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"className\":\"Layout_main__maYPe\",\"children\":[[\"$\",\"header\",null,{\"children\":[[\"$\",\"$L8\",null,{\"className\":\"Layout_logo__tEsDc\",\"href\":\"/\",\"children\":\"juchanei\"}],[\"$\",\"nav\",null,{\"children\":[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",\"/about\",{\"children\":[\"$\",\"$L8\",null,{\"href\":\"/about\",\"target\":\"$undefined\",\"children\":\"about\"}]}],[\"$\",\"li\",\"/articles\",{\"children\":[\"$\",\"$L8\",null,{\"href\":\"/articles\",\"target\":\"$undefined\",\"children\":\"articles\"}]}],[\"$\",\"li\",\"https://github.com/juchanei\",{\"children\":[\"$\",\"$L8\",null,{\"href\":\"https://github.com/juchanei\",\"target\":\"blank\",\"children\":\"github\"}]}]]}]}]]}],[\"$\",\"article\",null,{\"children\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"asNotFound\":false,\"childProp\":{\"current\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"articles\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"asNotFound\":false,\"childProp\":{\"current\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"articles\",\"children\",[\"slug\",\"Event-sourcing\",\"d\"],\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"asNotFound\":false,\"childProp\":{\"current\":[[\"$\",\"$Lb\",null,{\"title\":\"Event sourcing\",\"date\":\"$D2022-11-30T14:23:00.000Z\",\"tags\":[\"microservice\",\"transaction\",\"message\",\"event\"],\"html\":\"\u003cblockquote\u003e\\n\u003cp\u003e\u003ca href=\\\"https://microservices.io/patterns/data/event-sourcing.html\\\"\u003ehttps://microservices.io/patterns/data/event-sourcing.html\u003c/a\u003e을 번역한 글입니다.\u003c/p\u003e\\n\u003c/blockquote\u003e\\n\u003ch2 id=\\\"context\\\"\u003eContext\u003c/h2\u003e\\n\u003cp\u003e전형적인 서비스 커맨드는 데이터베이스를 업데이트 하는 동시에 메시지/이벤트를 발송할 필요가 있다. 예를 들면, \u003ca href=\\\"https://microservices.io/patterns/data/saga.html\\\"\u003esaga\u003c/a\u003e에 참여하는 서비스는 데이터베이스 업데이트와 메시지/이벤트 발행을 원자적으로 수행해야 한다. \u003ca href=\\\"https://microservices.io/patterns/data/domain-event.html\\\"\u003e도메인 이벤트\u003c/a\u003e(domain event)를 발행하는 서비스 역시 \u003ca href=\\\"https://microservices.io/patterns/data/aggregate.html\\\"\u003eaggregate\u003c/a\u003e을 업데이트하고 이벤트를 발행하는 동작을 원자적으로 수행해야 한다.\u003c/p\u003e\\n\u003cp\u003e서비스 커맨드는 일반적으로 데이터베이스를 업데이트하는 \u003cstrong\u003e동시에\u003c/strong\u003e 메시지/이벤트를 발송한다. 그러나 메시지 브로커는 보통 전통적인 분산 트랜잭션(Two phase commit, 2PC)를 지원하지 않기 때문에, 데이터베이스와 메시지 브로커에 걸쳐 업데이트와 메시지/이벤트 발행을 원자적으로 수행할 수 없다. 만약 가능하다 하더라도 서비스가 데이터베이스와 메시지에 모두 결합되는 구조는 바람직 하지 않을 수 있다.\u003c/p\u003e\\n\u003cp\u003e하지만 2PC를 사용하지 않으면, 트랜잭션 중에 메시지가 발송된 것을 확신할 수 없다. 트랜잭션이 커밋 되는 것을 보장할 수 없을 뿐만 아니라, 트랜잭션 커밋 후 메시지 발송 중에 크래시가 발생하지 않는다는 것 또한 보장할 수 없다.\u003c/p\u003e\\n\u003cp\u003e더불어, 메시지는 반드시 서비스가 발송한 순서대로 메시지 브로커에 도착해야 한다. 예를 들면, 서비스에서 한 aggregate이 트랜잭션 \u003ccode\u003eT1\u003c/code\u003e, \u003ccode\u003eT2\u003c/code\u003e에 의해 업데이트 된다고 하자. 두 트랜잭션은  같은 서비스 인스턴스에서 수행될 수도 있고 다른 서비스 인스턴스에서 수행될 수도 있다. 각각 트랜잭션은 대응되는 이벤트 \u003ccode\u003eE1\u003c/code\u003e, \u003ccode\u003eE2\u003c/code\u003e가 있다. 이 때 만일 트랜잭션 \u003ccode\u003eT1\u003c/code\u003e 다음에 \u003ccode\u003eT2\u003c/code\u003e가 수행된다면, 이벤트 \u003ccode\u003eE2\u003c/code\u003e는 반드시 \u003ccode\u003eE1\u003c/code\u003e 다음에 발행되어야 한다.\u003c/p\u003e\\n\u003ch2 id=\\\"problem\\\"\u003eProblem\u003c/h2\u003e\\n\u003cp\u003e어떻게 데이터베이스 업데이트와 메시지/이벤트 발행을 안정적/원자적으로 할 수 있을까?\u003c/p\u003e\\n\u003ch2 id=\\\"forces\\\"\u003eForces\u003c/h2\u003e\\n\u003cul\u003e\\n\u003cli\u003e2PC는 사용하지 않는다.\u003c/li\u003e\\n\u003cli\u003e만약 데이터베이스 트랜잭션이 커밋됐다면, 메시지는 반드시 발송되어야 한다. 반대로 데이터베이스가 롤백되었다면, 메시지는 발송되지 않아야 한다.\u003c/li\u003e\\n\u003cli\u003e메시지는 반드시 서비스가 발송한 순서대로 메시지 브로커에 도착해야 한다. 같은 aggregate을 업데이트하는 다수에 서비스 인스턴스에 걸쳐서 이 순서는 반드시 지켜져야 한다.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003ch2 id=\\\"solution\\\"\u003eSolution\u003c/h2\u003e\\n\u003cp\u003e이를 해결하기 위한 좋은 방안으로 이벤트 소싱이 있다. 이벤트 소싱은 \u003ccode\u003eOrder\u003c/code\u003e, \u003ccode\u003eCustomer\u003c/code\u003e와 같은 비즈니스 엔터티의 상태를 ‘연속된 상태 변화 이벤트’로 유지한다. 비즈니스 엔터티의 상태가 변경될 때 마다 이벤트 리스트에 새 이벤트가 추가된다. 이벤트를 한번에 저장하기 때문에 이 오퍼레이션은 기본적으로 원자적이다. 애플리케이션은 이 이벤트들을 다시 재생(replay)하여 엔터티를 재구성 한다.\u003c/p\u003e\\n\u003cp\u003e애플리케이션은 이벤트를 이벤트 스토어(데이터베이스)에 저장한다.  이벤트 스토어는 이벤트 저장, 조회 뿐만 아니라 메시지 브로커 처럼 이벤트를 구독할 수 있도록 API를 제공한다. 따라서 한 서비스가 이벤트를 스토어에 저장하면 이를 구독하는 서비스들에게 이벤트가 전달 된다.\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003eCustomer\u003c/code\u003e와 같이 일부 엔터티는 매우 많은 이벤트를 가질 수 있다. 로딩을 최적화 하기 위해서 애플리케이션은 현재 엔터티 상태의 스냅샷을 주기적으로 저장한다. 애플리케이션은 가장 최근 스냅샷과 그 이후에 발생한 이벤트를 찾아서 현재 상태를 재구성한다. 결과적으로 적은 수의 이벤트만 재생하여 현재 상태를 얻을 수 있다.\u003c/p\u003e\\n\u003ch2 id=\\\"example\\\"\u003eExample\u003c/h2\u003e\\n\u003cp\u003e아래는 이벤트 소싱과 \u003ca href=\\\"https://microservices.io/patterns/data/cqrs.html\\\"\u003eCQRS\u003c/a\u003e로 만든 \u003ca href=\\\"https://github.com/eventuate-examples/eventuate-examples-java-customers-and-orders\\\"\u003eCustomers and Orders 예제 애플리케이션\u003c/a\u003e의 일부이다. 어플리캐이션은 Java로 작성되었으며 Spring Boot와 \u003ca href=\\\"http://eventuate.io/\\\"\u003eEventuate\u003c/a\u003e를 사용한다.\u003c/p\u003e\\n\u003cp\u003e아래 다이어그램은 \u003ccode\u003eOrder\u003c/code\u003e를 어떻게 관리하는지 보여준다.\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://user-images.githubusercontent.com/10704195/204835063-c87078d7-26d6-4588-a052-460feaaf9c9e.png\\\" alt=\\\"image\\\"\u003e\u003c/p\u003e\\n\u003cp\u003e어플리케이션은 \u003ccode\u003eORDERS\u003c/code\u003e 테이블에 \u003ccode\u003eOrder\u003c/code\u003e의 현재 상태를 row로 저장하는 대신, 연속 된 \u003ccode\u003eOrder 이벤트\u003c/code\u003e를 저장한다. \u003ccode\u003eCustomerService\u003c/code\u003e는 \u003ccode\u003eOrder 이벤트\u003c/code\u003e를 구독하고 자기 자신의 상태를 업데이트한다.\u003c/p\u003e\\n\u003cp\u003e아래는 \u003ccode\u003eOrder\u003c/code\u003e aggregate이다\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"language-java\\\"\u003epublic class Order extends ReflectiveMutableCommandProcessingAggregate\u0026lt;Order, OrderCommand\u0026gt; {\\n\\n  private OrderState state;\\n  private String customerId;\\n\\n  public OrderState getState() {\\n    return state;\\n  }\\n\\n  public List\u0026lt;Event\u0026gt; process(CreateOrderCommand cmd) {\\n    return EventUtil.events(new OrderCreatedEvent(cmd.getCustomerId(), cmd.getOrderTotal()));\\n  }\\n\\n  public List\u0026lt;Event\u0026gt; process(ApproveOrderCommand cmd) {\\n    return EventUtil.events(new OrderApprovedEvent(customerId));\\n  }\\n\\n  public List\u0026lt;Event\u0026gt; process(RejectOrderCommand cmd) {\\n    return EventUtil.events(new OrderRejectedEvent(customerId));\\n  }\\n\\n  public void apply(OrderCreatedEvent event) {\\n    this.state = OrderState.CREATED;\\n    this.customerId = event.getCustomerId();\\n  }\\n\\n  public void apply(OrderApprovedEvent event) {\\n    this.state = OrderState.APPROVED;\\n  }\\n\\n  public void apply(OrderRejectedEvent event) {\\n    this.state = OrderState.REJECTED;\\n  }\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e아래는 \u003ccode\u003eOrder 이벤트\u003c/code\u003e를 구독하는 \u003ccode\u003eCustomerService\u003c/code\u003e의 이벤트 핸들러중 일부이다.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"language-java\\\"\u003e@EventSubscriber(id = \u0026quot;customerWorkflow\u0026quot;)\\npublic class CustomerWorkflow {\\n\\n  @EventHandlerMethod\\n  public CompletableFuture\u0026lt;EntityWithIdAndVersion\u0026lt;Customer\u0026gt;\u0026gt; reserveCredit(\\n          EventHandlerContext\u0026lt;OrderCreatedEvent\u0026gt; ctx) {\\n    OrderCreatedEvent event = ctx.getEvent();\\n    Money orderTotal = event.getOrderTotal();\\n    String customerId = event.getCustomerId();\\n    String orderId = ctx.getEntityId();\\n\\n    return ctx.update(Customer.class, customerId, new ReserveCreditCommand(orderTotal, orderId));\\n  }\\n\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e핸들러는 고객의 신용 예약을 시도하여 \u003ccode\u003eOrderCreated\u003c/code\u003e 이벤트를 처리한다.\u003c/p\u003e\\n\u003cp\u003e이 외에 이벤트 소싱을 어떻게 사용하는지 보여주는 \u003ca href=\\\"https://eventuate.io/exampleapps.html\\\"\u003e몇가지 예제 애플리케이션\u003c/a\u003e이 있다.\u003c/p\u003e\\n\u003ch2 id=\\\"resulting-context\\\"\u003eResulting context\u003c/h2\u003e\\n\u003cp\u003e이벤트 소싱의 장점\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e이벤트 소싱은 EDA(Event-driven Architecture)를 구현하는데 있어 주요한 문제들을 해결하며, 상태 변화마다 안정적으로 이벤트를 발행하도록 한다.\u003c/li\u003e\\n\u003cli\u003e도메인 객체 대신 이벤트를 저장하기 때문에 객체-관계형 데이터베이스 간의 임피던스 미스매칭 문제를 피할 수 있다.\u003c/li\u003e\\n\u003cli\u003e이벤트 소싱은 비즈니스 엔터티가 변경될 때 마다 100% 신뢰할 수 있는 \u003ca href=\\\"https://microservices.io/patterns/observability/audit-logging\\\"\u003eaudit log\u003c/a\u003e를 제공한다.\u003c/li\u003e\\n\u003cli\u003e특정 시점의 상태를 결정하기 위한 위한 임시 쿼리 구현할 수 있다.\u003c/li\u003e\\n\u003cli\u003e이벤트 소싱 기반의 비즈니스 로직은 이벤트를 교환하는 느슨하게 결합의 엔터티로 구성된다. 따라서 모놀로딕 애플리케이션에서 마이크로서비스 아키텍처로 쉽게 마이그레이션 할 수 있다.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003e이벤트 소싱의 단점\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e보통의 프로그래밍 스타일과 다르므로 러닝커브가 있다.\u003c/li\u003e\\n\u003cli\u003e스토어에 이벤트를 요청할 때 비즈니스 엔터티를 재구성하기 위한 반복적인 쿼리를 필요로 하기 때문에 어렵다. 이는 복잡하고 비효율적이다. 따라서, 어플리케이션은 반드시 \u003ca href=\\\"https://microservices.io/patterns/data/cqrs.html\\\"\u003eCQRS(Command Query Responsibility Segregation)\u003c/a\u003e을 사용하여야 한다. 어플리케이션은 반드시 ‘최종적으로 일관된 데이터’를 다뤄야 함을 의미한다.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003ch2 id=\\\"related-patterns\\\"\u003eRelated patterns\u003c/h2\u003e\\n\u003cul\u003e\\n\u003cli\u003e이 패턴을 \u003ca href=\\\"https://microservices.io/patterns/data/saga.html\\\"\u003eSaga\u003c/a\u003e와 \u003ca href=\\\"https://microservices.io/patterns/data/domain-event.html\\\"\u003eDomain event\u003c/a\u003e 패턴을 위해 만들어 졌다.\u003c/li\u003e\\n\u003cli\u003e높은 확률로 이벤트 소싱과 \u003ca href=\\\"https://microservices.io/patterns/data/cqrs.html\\\"\u003eCQRS\u003c/a\u003e는 함께 사용된다.\u003c/li\u003e\\n\u003cli\u003e이벤트 소싱은 \u003ca href=\\\"https://microservices.io/patterns/observability/audit-logging\\\"\u003eAudit logging\u003c/a\u003e 패턴을 구현한다.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003ch2 id=\\\"see-also\\\"\u003eSee also\u003c/h2\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003ca href=\\\"http://eventuate.io/\\\"\u003eEventuate\u003c/a\u003e은 이벤트 소싱과 CQRS 어플리케이션을 개발하기 위한 플랫폼이다.\u003c/li\u003e\\n\u003cli\u003e\u003ca href=\\\"https://eventuate.io/articles.html\\\"\u003e이벤트 소싱과 CQRS에 관한 아티클\u003c/a\u003e\u003c/li\u003e\\n\u003cli\u003e\u003ca href=\\\"https://blog.eventuate.io/2017/03/07/eventuate-local-now-supports-snapshots/\\\"\u003eEventuate가 스냅샷을 구현하는 방법\u003c/a\u003e\u003c/li\u003e\\n\u003c/ul\u003e\\n\"}],null],\"segment\":\"__PAGE__?{\\\"slug\\\":\\\"Event-sourcing\\\"}\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e175a87955b7f53c.css\",\"precedence\":\"next\"}]]}],\"segment\":[\"slug\",\"Event-sourcing\",\"d\"]},\"styles\":[]}],\"segment\":\"articles\"},\"styles\":[]}]}],[\"$\",\"footer\",null,{\"children\":[\"$\",\"span\",null,{\"children\":[\"Github (\",[\"$\",\"a\",null,{\"href\":\"https://github.com/juchanei\",\"children\":\"@juchanei\"}],\")\"]}]}]]}]}]]}],null]}]]\n"])</script><script>self.__next_f.push([1,"5:[[[\"$\",\"meta\",null,{\"charSet\":\"utf-8\"}],null,null,null,null,null,null,null,null,null,null,[\"$\",\"meta\",null,{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,null]\n"])</script>